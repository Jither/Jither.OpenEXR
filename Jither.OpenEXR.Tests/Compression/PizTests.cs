using System.Buffers;

namespace Jither.OpenEXR.Compression;

/// <summary>
/// Tests of PIZ compression.
/// Test data for some of these tests was stolen from https://github.com/johannesvollmer/exrs
/// - even when it wouldn't need to be.
/// </summary>
public class PizTests
{
    [Theory]
    [InlineData(13, 54)]
    [InlineData(3, 123)]
    [InlineData(423, 53)]
    [InlineData(1, 23)]
    [InlineData(23, 515)]
    [InlineData(513, 43)]
    [InlineData(16374, 16381)]
    [InlineData(16284, 3)]
    [InlineData(2, 1)]
    [InlineData(0, 0)]
    [InlineData(0, 4)]
    [InlineData(3, 0)]
    public void Wavelet_Encode14_does_proper_roundtrip(ushort a, ushort b)
    {
        (ushort l, ushort h) = Wavelet.Encode14(a, b);
        (ushort actualA, ushort actualB) = Wavelet.Decode14(l, h);
        Assert.Equal(a, actualA);
        Assert.Equal(b, actualB);
    }

    [Theory]
    [InlineData(13, 54)]
    [InlineData(3, 123)]
    [InlineData(423, 53)]
    [InlineData(1, 23)]
    [InlineData(23, 515)]
    [InlineData(513, 43)]
    [InlineData(16385, 56384)] // !!! > 14 bit
    [InlineData(18384, 36384)] // !!! > 14 bit
    [InlineData(2, 1)]
    [InlineData(0, 0)]
    [InlineData(0, 4)]
    [InlineData(3, 0)]
    public void Wavelet_Encode16_does_proper_roundtrip(ushort a, ushort b)
    {
        (ushort l, ushort h) = Wavelet.Encode16(a, b);
        (ushort actualA, ushort actualB) = Wavelet.Decode16(l, h);
        Assert.Equal(a, actualA);
        Assert.Equal(b, actualB);
    }

    [Fact]
    public void Roundtrips_14bit_image()
    {
        ushort[] original = {
            13, 54, 3, 123, 423, 53,
            1, 23, 23, 515, 513, 43,
            16374, 16381, 16284, 3, 2, 1,
            0, 0, 0, 4, 3, 0
        };
        ushort max = original.Max();
        ushort[] transformed = (ushort[])original.Clone();

        Wavelet.Encode2D(transformed, 6, 1, 4, 6, max);
        Assert.NotEqual(original, transformed);
        Wavelet.Decode2D(transformed, 6, 1, 4, 6, max);
        Assert.Equal(original, transformed);
    }

    [Fact]
    public void Roundtrips_16bit_image()
    {
        ushort[] original = {
            13, 54, 3, 123, 423, 53,
            1, 23, 23, 515, 513, 43,
            16385, 56384, 18384, 36384, 2, 1,
            0, 0, 0, 4, 3, 0
        };
        ushort max = original.Max();
        ushort[] transformed = (ushort[])original.Clone();

        Wavelet.Encode2D(transformed, 6, 1, 4, 6, max);
        Assert.NotEqual(original, transformed);
        Wavelet.Decode2D(transformed, 6, 1, 4, 6, max);
        Assert.Equal(original, transformed);
    }

    ushort[] noise_14bit(Random rnd, int size)
    {
        var result = new ushort[size];
        for (int i = 0; i < size; i++)
        {
            result[i] = (ushort)(rnd.Next() & 0x3fff);
        }
        return result;
    }

    ushort[] noise_16bit(Random rnd, int size)
    {
        var result = new ushort[size];
        for (int i = 0; i < size; i++)
        {
            result[i] = (ushort)(rnd.Next() & 0xffff);
        }
        return result;
    }

    [Theory]
    [InlineData(1, 1)]
    [InlineData(2, 2)]
    [InlineData(32, 32)]
    [InlineData(1024, 16)]
    [InlineData(16, 1024)]
    [InlineData(997, 37)]
    [InlineData(37, 997)]
    [InlineData(1024, 1024)]
    [InlineData(997, 997)]
    public void Ground_truth(int width, int height)
    {
        var rnd = new Random(31234);

        int size = width * height;

        roundtrip(noise_14bit(rnd, size));
        roundtrip(noise_14bit(rnd, size));
        roundtrip(noise_16bit(rnd, size));
        roundtrip(solid(0));
        roundtrip(solid(1));
        roundtrip(solid(0xffff));
        roundtrip(solid(0x3fff));
        roundtrip(solid(0x3ffe));
        roundtrip(solid(0x3fff));
        roundtrip(solid(0xfffe));
        roundtrip(solid(0xffff));
        roundtrip(verticals(0xffff));
        roundtrip(verticals(0x3fff));
        roundtrip(horizontals(0xffff));
        roundtrip(horizontals(0x3fff));
        roundtrip(diagonals(0xffff));
        roundtrip(diagonals(0x3fff));

        void roundtrip(ushort[] original) {
            ushort max = original.Max();
            ushort[] transformed = (ushort[])original.Clone();

            Wavelet.Encode2D(transformed, width, 1, height, width, max);
            Wavelet.Decode2D(transformed, width, 1, height, width, max);
            Assert.Equal(original, transformed);
        }

        ushort[] solid(ushort value) {
            var result = new ushort[size];
            Array.Fill(result, value);
            return result;
        }

        ushort[] verticals(ushort maxValue)
        {
            return Enumerable.Repeat(Enumerable.Range(0, width).Select(x => (x & 1) != 0 ? (ushort)0 : maxValue), height).SelectMany(line => line).ToArray();
        }

        ushort[] horizontals(ushort maxValue)
        {
            return Enumerable.Range(0, height).Select(y => Enumerable.Repeat((y & 1) != 0 ? (ushort)0 : maxValue, width)).SelectMany(line => line).ToArray();
        }

        ushort[] diagonals(ushort maxValue)
        {
            return Enumerable.Range(0, height).Select(y => Enumerable.Range(0, width).Select(x => ((x + y) & 1) != 0 ? (ushort)0 : maxValue)).SelectMany(line => line).ToArray();
        }
    }

    private static readonly ushort[] UNCOMPRESSED_ARRAY = {
        3852, 2432, 33635, 49381, 10100, 15095, 62693, 63738, 62359, 5013, 7715, 59875, 28182,
        34449, 19983, 20399, 63407, 29486, 4877, 26738, 44815, 14042, 46091, 48228, 25682, 35412,
        7582, 65069, 6632, 54124, 13798, 27503, 52154, 61961, 30474, 46880, 39097, 15754, 52897,
        42371, 54053, 14178, 48276, 34591, 42602, 32126, 42062, 31474, 16274, 55991, 2882, 17039,
        56389, 20835, 57057, 54081, 3414, 33957, 52584, 10222, 25139, 40002, 44980, 1602, 48021,
        19703, 6562, 61777, 41582, 201, 31253, 51790, 15888, 40921, 3627, 12184, 16036, 26349,
        3159, 29002, 14535, 50632, 18118, 33583, 18878, 59470, 32835, 9347, 16991, 21303, 26263,
        8312, 14017, 41777, 43240, 3500, 60250, 52437, 45715, 61520,
    };

    private static readonly byte[] COMPRESSED_ARRAY =
    {
        0xc9, 0x0, 0x0, 0x0, 0x2e, 0xfe, 0x0, 0x0, 0x56, 0x2, 0x0, 0x0, 0xa2, 0x2, 0x0, 0x0, 0x0,
        0x0, 0x0, 0x0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd6, 0x47,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x28, 0x1f, 0xff, 0xff, 0xed, 0x87, 0xff, 0xff, 0xf0,
        0x91, 0xff, 0xf8, 0x1f, 0xf4, 0xf1, 0xff, 0x78, 0x1f, 0xfd, 0xa1, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xfa, 0xc7, 0xfe, 0x4, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xed, 0x1f, 0xf3, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe8, 0x7, 0xfd, 0xf8,
        0x7f, 0xff, 0xff, 0xff, 0xfd, 0x10, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x51, 0xff,
        0xff, 0xff, 0xff, 0xfe, 0x1, 0xff, 0x73, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xfc, 0xa4, 0x7f, 0xf5, 0x7, 0xfc, 0x48, 0x7f, 0xe0, 0x47, 0xff, 0xff,
        0xf5, 0x91, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xf1, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x21, 0xff,
        0x7f, 0x1f, 0xf8, 0xd1, 0xff, 0xe7, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xbc, 0x1f, 0xf2, 0x91,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1c, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xe7,
        0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x8c, 0x7f, 0xff, 0xff, 0xc, 0x1f, 0xff, 0xff,
        0xe5, 0x7, 0xff, 0xff, 0xfa, 0x81, 0xff, 0xff, 0xff, 0x20, 0x7f, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xbc, 0x7f, 0xff, 0xff, 0xff, 0xfc, 0x38, 0x7f, 0xff,
        0xff, 0xff, 0xfc, 0xd0, 0x7f, 0xd3, 0xc7, 0xff, 0xff, 0xf7, 0x91, 0xff, 0xff, 0xff, 0xff,
        0xfe, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xf9, 0x61, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7,
        0x87, 0xff, 0xff, 0xfd, 0x81, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x87, 0xff, 0xff,
        0xff, 0xff, 0xfe, 0x87, 0xff, 0x58, 0x7f, 0xff, 0xff, 0xff, 0xfd, 0xec, 0x7f, 0xff, 0xff,
        0xff, 0xfe, 0xd0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x6c, 0x7f, 0xcb, 0x47, 0xff, 0xff, 0xf3,
        0x61, 0xff, 0xff, 0xff, 0x80, 0x7f, 0xe1, 0xc7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f,
        0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x18, 0x1f, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xfd, 0xcc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x11, 0xff, 0xff,
        0xff, 0xff, 0xf8, 0x41, 0xff, 0xbc, 0x1f, 0xff, 0xff, 0xc4, 0x47, 0xff, 0xff, 0xf2, 0x91,
        0xff, 0xe0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0x6d, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x2, 0x1f, 0xf9, 0xe1, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xe1,
        0xff, 0xff, 0xfd, 0xb0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe1, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0x5a, 0x1f, 0xfc, 0x81, 0xbf, 0x29, 0x1b, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xf3, 0x61, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc8, 0x1b,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf6, 0xb1, 0xbf, 0xff, 0xfd, 0x80, 0x6f, 0xff,
        0xff, 0xf, 0x1b, 0xf8, 0xc1, 0xbf, 0xff, 0xfc, 0xb4, 0x6f, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xda, 0x46, 0xfc, 0x54, 0x6f, 0xc9, 0x6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x21, 0x1b, 0xff, 0xff, 0xe0, 0x86, 0xff, 0xff,
        0xff, 0xff, 0xe2, 0xc6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x91, 0xbf, 0xff, 0xfe, 0x24, 0x6f, 0xff, 0xff, 0x6b,
        0x1b, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xb1, 0xbf, 0xfa, 0x1b, 0xfb, 0x11,
        0xbf, 0xff, 0xfe, 0x8, 0x6f, 0xff, 0xff, 0x42, 0x1b, 0xff, 0xff, 0xff, 0xff, 0xb9, 0x1b,
        0xff, 0xff, 0xcf, 0xc6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0x31,
        0x86, 0x10, 0x9, 0xb4, 0xe4, 0x4c, 0xf7, 0xef, 0x42, 0x87, 0x6a, 0xb5, 0xc2, 0x34, 0x9e,
        0x2f, 0x12, 0xae, 0x21, 0x68, 0xf2, 0xa8, 0x74, 0x37, 0xe1, 0x98, 0x14, 0x59, 0x57, 0x2c,
        0x24, 0x3b, 0x35, 0x6c, 0x1b, 0x8b, 0xcc, 0xe6, 0x13, 0x38, 0xc, 0x8e, 0xe2, 0xc, 0xfe,
        0x49, 0x73, 0xbc, 0x2b, 0x7b, 0x9, 0x27, 0x79, 0x14, 0xc, 0x94, 0x42, 0xf8, 0x7c, 0x1,
        0x8d, 0x26, 0xde, 0x87, 0x26, 0x71, 0x50, 0x45, 0xc6, 0x28, 0x40, 0xd5, 0xe, 0x8d, 0x8,
        0x1e, 0x4c, 0xa4, 0x79, 0x57, 0xf0, 0xc3, 0x6d, 0x5c, 0x6d, 0xc0
    };

    private static readonly ushort[] UNCOMPRESSED_ARRAY_SPECIAL =
    {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 28182,
        0, 65534, 0, 65534, 0, 65534, 0, 65534, 0, 0, 0, 0, 0,
        0, 0, 0, 54124, 13798, 27503, 52154, 61961, 30474, 46880, 39097, 15754, 52897,
        42371, 54053, 14178, 48276, 34591, 42602, 32126, 42062, 31474, 16274, 55991, 2882, 17039,
        56389, 20835, 57057, 54081, 3414, 33957, 52584, 10222, 25139, 40002, 44980, 1602, 48021,
        19703, 6562, 61777, 41582, 201, 31253, 51790, 15888, 40921, 3627, 12184, 16036, 26349,
        3159, 29002, 14535, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        65534, 65534, 65534, 65534, 65534, 65534, 65534, 65534, 65534
    };

    [Fact]
    void Huffman_repetitions_special()
    {
        var uncompressed = UNCOMPRESSED_ARRAY_SPECIAL;
        var compressed = HuffmanCoding.Compress(uncompressed);
        ushort[] decompressed = new ushort[uncompressed.Length];
        HuffmanCoding.Decompress(compressed, decompressed, compressed.Length);
        Assert.Equal(uncompressed, decompressed);
    }

    [Fact]
    void Huffman_zeroes()
    {
        var uncompressed = new ushort[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
        var compressed = HuffmanCoding.Compress(uncompressed);
        ushort[] decompressed = new ushort[uncompressed.Length];
        HuffmanCoding.Decompress(compressed, decompressed, compressed.Length);
        Assert.Equal(uncompressed, decompressed);
    }

    [Fact]
    void Huffman_compression_result()
    {
        var compressed = HuffmanCoding.Compress(UNCOMPRESSED_ARRAY);
        Assert.Equal(COMPRESSED_ARRAY, compressed);
    }

    [Fact]
    void Huffman_longcodes()
    {
        // This exercises the longcode implementation
        var rnd = new Random(1234);

        var uncompressed = noise_16bit(rnd, 17000);
        var compressed = HuffmanCoding.Compress(uncompressed);
        var decompressed = new ushort[uncompressed.Length];
        HuffmanCoding.Decompress(compressed, decompressed);
        Assert.Equal(uncompressed, decompressed);
    }
}
